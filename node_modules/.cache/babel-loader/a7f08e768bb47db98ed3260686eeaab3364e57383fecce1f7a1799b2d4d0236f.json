{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link module:workbox-routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n *\n * @memberof module:workbox-routing\n * @extends module:workbox-routing.Route\n */\nclass RegExpRoute extends Route {\n  /**\n   * If the regular expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * the captured values will be passed to the\n   * [handler's]{@link module:workbox-routing~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {module:workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern'\n      });\n    }\n    const match = _ref => {\n      let {\n        url\n      } = _ref;\n      const result = regExp.exec(url.href);\n      // Return immediately if there's no match.\n      if (!result) {\n        return;\n      }\n      // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n      if (url.origin !== location.origin && result.index !== 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`The regular expression '${regExp}' only partially matched ` + `against the cross-origin URL '${url}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n        }\n        return;\n      }\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n    super(match, handler, method);\n  }\n}\nexport { RegExpRoute };","map":{"version":3,"names":["assert","logger","Route","RegExpRoute","constructor","regExp","handler","method","process","env","NODE_ENV","isInstance","RegExp","moduleName","className","funcName","paramName","match","_ref","url","result","exec","href","origin","location","index","debug","slice"],"sources":["/Users/aliciamedina/Library/Mobile Documents/com~apple~CloudDocs/Work/Proyecto Fin Grado/Electron/Ionic/Chatty-iOS/node_modules/workbox-routing/RegExpRoute.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link module:workbox-routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n *\n * @memberof module:workbox-routing\n * @extends module:workbox-routing.Route\n */\nclass RegExpRoute extends Route {\n    /**\n     * If the regular expression contains\n     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n     * the captured values will be passed to the\n     * [handler's]{@link module:workbox-routing~handlerCallback} `params`\n     * argument.\n     *\n     * @param {RegExp} regExp The regular expression to match against URLs.\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(regExp, handler, method) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(regExp, RegExp, {\n                moduleName: 'workbox-routing',\n                className: 'RegExpRoute',\n                funcName: 'constructor',\n                paramName: 'pattern',\n            });\n        }\n        const match = ({ url }) => {\n            const result = regExp.exec(url.href);\n            // Return immediately if there's no match.\n            if (!result) {\n                return;\n            }\n            // Require that the match start at the first character in the URL string\n            // if it's a cross-origin request.\n            // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n            // behind this behavior.\n            if ((url.origin !== location.origin) && (result.index !== 0)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`The regular expression '${regExp}' only partially matched ` +\n                        `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\n                        `handle cross-origin requests if they match the entire URL.`);\n                }\n                return;\n            }\n            // If the route matches, but there aren't any capture groups defined, then\n            // this will return [], which is truthy and therefore sufficient to\n            // indicate a match.\n            // If there are capture groups, then it will return their values.\n            return result.slice(1);\n        };\n        super(match, handler, method);\n    }\n}\nexport { RegExpRoute };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,iCAAiC;AACxD,SAASC,MAAM,QAAQ,iCAAiC;AACxD,SAASC,KAAK,QAAQ,YAAY;AAClC,OAAO,eAAe;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,SAASD,KAAK,CAAC;EAC5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAE;IACjC,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACvCV,MAAM,CAACW,UAAU,CAACN,MAAM,EAAEO,MAAM,EAAE;QAC9BC,UAAU,EAAE,iBAAiB;QAC7BC,SAAS,EAAE,aAAa;QACxBC,QAAQ,EAAE,aAAa;QACvBC,SAAS,EAAE;MACf,CAAC,CAAC;IACN;IACA,MAAMC,KAAK,GAAGC,IAAA,IAAa;MAAA,IAAZ;QAAEC;MAAI,CAAC,GAAAD,IAAA;MAClB,MAAME,MAAM,GAAGf,MAAM,CAACgB,IAAI,CAACF,GAAG,CAACG,IAAI,CAAC;MACpC;MACA,IAAI,CAACF,MAAM,EAAE;QACT;MACJ;MACA;MACA;MACA;MACA;MACA,IAAKD,GAAG,CAACI,MAAM,KAAKC,QAAQ,CAACD,MAAM,IAAMH,MAAM,CAACK,KAAK,KAAK,CAAE,EAAE;QAC1D,IAAIjB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACvCT,MAAM,CAACyB,KAAK,CAAE,2BAA0BrB,MAAO,2BAA0B,GACpE,iCAAgCc,GAAI,6BAA4B,GAChE,4DAA2D,CAAC;QACrE;QACA;MACJ;MACA;MACA;MACA;MACA;MACA,OAAOC,MAAM,CAACO,KAAK,CAAC,CAAC,CAAC;IAC1B,CAAC;IACD,KAAK,CAACV,KAAK,EAAEX,OAAO,EAAEC,MAAM,CAAC;EACjC;AACJ;AACA,SAASJ,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}
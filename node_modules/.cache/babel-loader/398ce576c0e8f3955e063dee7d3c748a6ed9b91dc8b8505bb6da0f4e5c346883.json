{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version) {\n    let {\n      onupgradeneeded,\n      onversionchange\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this._db = null;\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange || (() => this.close());\n  }\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   * @return {IDBDatabase|undefined}\n   *\n   * @private\n   */\n  get db() {\n    return this._db;\n  }\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n  async open() {\n    if (this._db) return;\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = () => reject(openRequest.error);\n      openRequest.onupgradeneeded = evt => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          openRequest.result.close();\n        } else if (typeof this._onupgradeneeded === 'function') {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = () => {\n        const db = openRequest.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {\n      query,\n      count\n    });\n  }\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAllKeys(storeName, query, count) {\n    const entries = await this.getAllMatching(storeName, {\n      query,\n      count,\n      includeKeys: true\n    });\n    return entries.map(entry => entry.key);\n  }\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n  async getAllMatching(storeName) {\n    let {\n      index,\n      query = null,\n      // IE/Edge errors if query === `undefined`.\n      direction = 'next',\n      count,\n      includeKeys = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n      const request = target.openCursor(query, direction);\n      request.onsuccess = () => {\n        const cursor = request.result;\n        if (cursor) {\n          results.push(includeKeys ? cursor : cursor.value);\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      txn.onabort = () => reject(txn.error);\n      txn.oncomplete = () => resolve();\n      callback(txn, value => resolve(value));\n    });\n  }\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n  async _call(method, storeName, type) {\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n    const callback = (txn, done) => {\n      const objStore = txn.objectStore(storeName);\n      // TODO(philipwalton): Fix this underlying TS2684 error.\n      // @ts-ignore\n      const request = objStore[method].apply(objStore, args);\n      request.onsuccess = () => done(request.result);\n    };\n    return await this.transaction([storeName], type, callback);\n  }\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n  close() {\n    if (this._db) {\n      this._db.close();\n      this._db = null;\n    }\n  }\n}\n// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n  readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  readwrite: ['add', 'put', 'clear', 'delete']\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function (storeName) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}","map":{"version":3,"names":["DBWrapper","constructor","name","version","onupgradeneeded","onversionchange","arguments","length","undefined","_db","_name","_version","_onupgradeneeded","_onversionchange","close","db","open","Promise","resolve","reject","openRequestTimedOut","setTimeout","Error","OPEN_TIMEOUT","openRequest","indexedDB","onerror","error","evt","transaction","abort","result","onsuccess","bind","getKey","storeName","query","getAllKeys","getAll","count","getAllMatching","entries","includeKeys","map","entry","key","index","direction","txn","done","store","objectStore","target","results","request","openCursor","cursor","push","value","continue","storeNames","type","callback","onabort","oncomplete","_call","method","_len","args","Array","_key","objStore","apply","prototype","methodsToWrap","readonly","readwrite","mode","methods","Object","IDBObjectStore","_len2","_key2"],"sources":["/Users/aliciamedina/Library/Mobile Documents/com~apple~CloudDocs/Work/Proyecto Fin Grado/Electron/Ionic/Chatty-iOS/node_modules/workbox-core/_private/DBWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n    /**\n     * @param {string} name\n     * @param {number} version\n     * @param {Object=} [callback]\n     * @param {!Function} [callbacks.onupgradeneeded]\n     * @param {!Function} [callbacks.onversionchange] Defaults to\n     *     DBWrapper.prototype._onversionchange when not specified.\n     * @private\n     */\n    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {\n        this._db = null;\n        this._name = name;\n        this._version = version;\n        this._onupgradeneeded = onupgradeneeded;\n        this._onversionchange = onversionchange || (() => this.close());\n    }\n    /**\n     * Returns the IDBDatabase instance (not normally needed).\n     * @return {IDBDatabase|undefined}\n     *\n     * @private\n     */\n    get db() {\n        return this._db;\n    }\n    /**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     * @private\n     */\n    async open() {\n        if (this._db)\n            return;\n        this._db = await new Promise((resolve, reject) => {\n            // This flag is flipped to true if the timeout callback runs prior\n            // to the request failing or succeeding. Note: we use a timeout instead\n            // of an onblocked handler since there are cases where onblocked will\n            // never never run. A timeout better handles all possible scenarios:\n            // https://github.com/w3c/IndexedDB/issues/223\n            let openRequestTimedOut = false;\n            setTimeout(() => {\n                openRequestTimedOut = true;\n                reject(new Error('The open request was blocked and timed out'));\n            }, this.OPEN_TIMEOUT);\n            const openRequest = indexedDB.open(this._name, this._version);\n            openRequest.onerror = () => reject(openRequest.error);\n            openRequest.onupgradeneeded = (evt) => {\n                if (openRequestTimedOut) {\n                    openRequest.transaction.abort();\n                    openRequest.result.close();\n                }\n                else if (typeof this._onupgradeneeded === 'function') {\n                    this._onupgradeneeded(evt);\n                }\n            };\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                if (openRequestTimedOut) {\n                    db.close();\n                }\n                else {\n                    db.onversionchange = this._onversionchange.bind(this);\n                    resolve(db);\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     * @private\n     */\n    async getKey(storeName, query) {\n        return (await this.getAllKeys(storeName, query, 1))[0];\n    }\n    /**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAll(storeName, query, count) {\n        return await this.getAllMatching(storeName, { query, count });\n    }\n    /**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAllKeys(storeName, query, count) {\n        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });\n        return entries.map((entry) => entry.key);\n    }\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     * @private\n     */\n    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.\n    direction = 'next', count, includeKeys = false, } = {}) {\n        return await this.transaction([storeName], 'readonly', (txn, done) => {\n            const store = txn.objectStore(storeName);\n            const target = index ? store.index(index) : store;\n            const results = [];\n            const request = target.openCursor(query, direction);\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    results.push(includeKeys ? cursor : cursor.value);\n                    if (count && results.length >= count) {\n                        done(results);\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    done(results);\n                }\n            };\n        });\n    }\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     * @private\n     */\n    async transaction(storeNames, type, callback) {\n        await this.open();\n        return await new Promise((resolve, reject) => {\n            const txn = this._db.transaction(storeNames, type);\n            txn.onabort = () => reject(txn.error);\n            txn.oncomplete = () => resolve();\n            callback(txn, (value) => resolve(value));\n        });\n    }\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     * @private\n     */\n    async _call(method, storeName, type, ...args) {\n        const callback = (txn, done) => {\n            const objStore = txn.objectStore(storeName);\n            // TODO(philipwalton): Fix this underlying TS2684 error.\n            // @ts-ignore\n            const request = objStore[method].apply(objStore, args);\n            request.onsuccess = () => done(request.result);\n        };\n        return await this.transaction([storeName], type, callback);\n    }\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */\n    close() {\n        if (this._db) {\n            this._db.close();\n            this._db = null;\n        }\n    }\n}\n// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n    readwrite: ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n    for (const method of methods) {\n        if (method in IDBObjectStore.prototype) {\n            // Don't use arrow functions here since we're outside of the class.\n            DBWrapper.prototype[method] =\n                async function (storeName, ...args) {\n                    return await this._call(method, storeName, mode, ...args);\n                };\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof module:workbox-expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._isRunning = false;\n    this._rerunRequested = false;\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName'\n      });\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor'\n        });\n      }\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n        // TODO: Assert is positive\n      }\n    }\n\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n    // Delete URLs from the cache\n    const cache = await self.caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n        urlsExpired.forEach(url => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      dontWaitFor(this.expireEntries());\n    }\n  }\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url'\n      });\n    }\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (!this._maxAgeSeconds) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds'\n        });\n      }\n      return false;\n    } else {\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp < expireOlderThan;\n    }\n  }\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport { CacheExpiration };","map":{"version":3,"names":["assert","dontWaitFor","logger","WorkboxError","CacheTimestampsModel","CacheExpiration","constructor","cacheName","config","arguments","length","undefined","_isRunning","_rerunRequested","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","_maxEntries","_maxAgeSeconds","_cacheName","_timestampModel","expireEntries","minTimestamp","Date","now","urlsExpired","cache","self","caches","open","url","delete","groupCollapsed","log","forEach","groupEnd","debug","updateTimestamp","setTimestamp","isURLExpired","methodName","timestamp","getTimestamp","expireOlderThan","Infinity"],"sources":["/Users/aliciamedina/Library/Mobile Documents/com~apple~CloudDocs/Work/Proyecto Fin Grado/Electron/Ionic/Chatty-iOS/node_modules/workbox-expiration/CacheExpiration.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof module:workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n                // TODO: Assert is positive\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n                // TODO: Assert is positive\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ?\n            Date.now() - (this._maxAgeSeconds * 1000) : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ?\n                    'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n            return (timestamp < expireOlderThan);\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async _ref => {\n  let {\n    request,\n    mode,\n    plugins = []\n  } = _ref;\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n  let effectiveRequest = request;\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, {\n      mode,\n      request: effectiveRequest\n    });\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n        isReturnValueProblem: true\n      });\n    }\n  }\n  return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async _ref2 => {\n  let {\n    request,\n    response,\n    event,\n    plugins = []\n  } = _ref2;\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (const plugin of plugins) {\n    if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n      pluginsUsed = true;\n      const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n      responseToCache = await pluginMethod.call(plugin, {\n        request,\n        response: responseToCache,\n        event\n      });\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n            isReturnValueProblem: true\n          });\n        }\n      }\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (responseToCache) {\n        if (responseToCache.status !== 200) {\n          if (responseToCache.status === 0) {\n            logger.warn(`The response for '${request.url}' is an opaque ` + `response. The caching strategy that you're using will not ` + `cache opaque responses by default.`);\n          } else {\n            logger.debug(`The response for '${request.url}' returned ` + `a status code of '${response.status}' and won't be cached as a ` + `result.`);\n          }\n        }\n      }\n    }\n    responseToCache = responseToCache && responseToCache.status === 200 ? responseToCache : undefined;\n  }\n  return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async _ref3 => {\n  let {\n    cacheName,\n    request,\n    event,\n    matchOptions,\n    plugins = []\n  } = _ref3;\n  const cache = await self.caches.open(cacheName);\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'read'\n  });\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n  for (const plugin of plugins) {\n    if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n      const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n      cachedResponse = await pluginMethod.call(plugin, {\n        cacheName,\n        event,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest\n      });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n            isReturnValueProblem: true\n          });\n        }\n      }\n    }\n  }\n  return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async _ref4 => {\n  let {\n    cacheName,\n    request,\n    response,\n    event,\n    plugins = [],\n    matchOptions\n  } = _ref4;\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method\n      });\n    }\n  }\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'write'\n  });\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url)\n    });\n  }\n  const responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest\n  });\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` + `not be cached.`, responseToCache);\n    }\n    return;\n  }\n  const cache = await self.caches.open(cacheName);\n  const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n  const oldResponse = updatePlugins.length > 0 ? await matchWrapper({\n    cacheName,\n    matchOptions,\n    request: effectiveRequest\n  }) : null;\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` + `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n  for (const plugin of updatePlugins) {\n    await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest\n    });\n  }\n};\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};","map":{"version":3,"names":["assert","executeQuotaErrorCallbacks","getFriendlyURL","logger","pluginUtils","WorkboxError","_getEffectiveRequest","_ref","request","mode","plugins","cacheKeyWillBeUsedPlugins","filter","effectiveRequest","plugin","call","Request","process","env","NODE_ENV","isInstance","moduleName","funcName","isReturnValueProblem","_isResponseSafeToCache","_ref2","response","event","responseToCache","pluginsUsed","pluginMethod","Response","status","warn","url","debug","undefined","matchWrapper","_ref3","cacheName","matchOptions","cache","self","caches","open","cachedResponse","match","putWrapper","_ref4","method","error","updatePlugins","oldResponse","length","put","name","newResponse","cacheWrapper"],"sources":["/Users/aliciamedina/Library/Mobile Documents/com~apple~CloudDocs/Work/Proyecto Fin Grado/Electron/Ionic/Chatty-iOS/node_modules/workbox-core/_private/cacheWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n    let effectiveRequest = request;\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\n        if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n                isReturnValueProblem: true,\n            });\n        }\n    }\n    return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const plugin of plugins) {\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n            pluginsUsed = true;\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n            responseToCache = await pluginMethod.call(plugin, {\n                request,\n                response: responseToCache,\n                event,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    assert.isInstance(responseToCache, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n            if (!responseToCache) {\n                break;\n            }\n        }\n    }\n    if (!pluginsUsed) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\n                            `response. The caching strategy that you're using will not ` +\n                            `cache opaque responses by default.`);\n                    }\n                    else {\n                        logger.debug(`The response for '${request.url}' returned ` +\n                            `a status code of '${response.status}' and won't be cached as a ` +\n                            `result.`);\n                    }\n                }\n            }\n        }\n        responseToCache = responseToCache && responseToCache.status === 200 ?\n            responseToCache : undefined;\n    }\n    return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\n    const cache = await self.caches.open(cacheName);\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'read'\n    });\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n        }\n        else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n    }\n    for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n            cachedResponse = await pluginMethod.call(plugin, {\n                cacheName,\n                event,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    assert.isInstance(cachedResponse, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n        }\n    }\n    return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (request.method && request.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(request.url),\n                method: request.method,\n            });\n        }\n    }\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'write'\n    });\n    if (!response) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Cannot cache non-existent response for ` +\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n        throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url),\n        });\n    }\n    const responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest,\n    });\n    if (!responseToCache) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n                `not be cached.`, responseToCache);\n        }\n        return;\n    }\n    const cache = await self.caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n    const oldResponse = updatePlugins.length > 0 ?\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\n        null;\n    if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n            `${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n        await cache.put(effectiveRequest, responseToCache);\n    }\n    catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n            await executeQuotaErrorCallbacks();\n        }\n        throw error;\n    }\n    for (const plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName,\n            event,\n            oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest,\n        });\n    }\n};\nexport const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
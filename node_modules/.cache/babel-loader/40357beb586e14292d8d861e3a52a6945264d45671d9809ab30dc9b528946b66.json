{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n    const urlsToWarnAbout = [];\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n      this._urlsToCacheModes.set(url, cacheMode);\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n        if (process.env.NODE_ENV === 'production') {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {\n          logger.warn(warningMessage);\n        }\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<module:workbox-precaching.InstallResult>}\n   */\n  async install() {\n    let {\n      event,\n      plugins\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins'\n        });\n      }\n    }\n    const toBePrecached = [];\n    const alreadyPrecached = [];\n    const cache = await self.caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const existingCacheKeys = new Set(alreadyCachedRequests.map(request => request.url));\n    for (const [url, cacheKey] of this._urlsToCacheKeys) {\n      if (existingCacheKeys.has(cacheKey)) {\n        alreadyPrecached.push(url);\n      } else {\n        toBePrecached.push({\n          cacheKey,\n          url\n        });\n      }\n    }\n    const precacheRequests = toBePrecached.map(_ref => {\n      let {\n        cacheKey,\n        url\n      } = _ref;\n      const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n      const cacheMode = this._urlsToCacheModes.get(url);\n      return this._addURLToCache({\n        cacheKey,\n        cacheMode,\n        event,\n        integrity,\n        plugins,\n        url\n      });\n    });\n    await Promise.all(precacheRequests);\n    const updatedURLs = toBePrecached.map(item => item.url);\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(updatedURLs, alreadyPrecached);\n    }\n    return {\n      updatedURLs,\n      notUpdatedURLs: alreadyPrecached\n    };\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<module:workbox-precaching.CleanupResult>}\n   */\n  async activate() {\n    const cache = await self.caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n    const deletedURLs = [];\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n    return {\n      deletedURLs\n    };\n  }\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.cacheKey The string to use a cache key.\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {string} [options.cacheMode] The cache mode for the network request.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   * @param {string} [options.integrity] The value to use for the `integrity`\n   * field when making the request.\n   */\n  async _addURLToCache(_ref2) {\n    let {\n      cacheKey,\n      url,\n      cacheMode,\n      event,\n      plugins,\n      integrity\n    } = _ref2;\n    const request = new Request(url, {\n      integrity,\n      cache: cacheMode,\n      credentials: 'same-origin'\n    });\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request\n    });\n    // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a `CacheableResponsePlugin` instance.\n    let cacheWillUpdatePlugin;\n    for (const plugin of plugins || []) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdatePlugin = plugin;\n      }\n    }\n    const isValidResponse = cacheWillUpdatePlugin ?\n    // Use a callback if provided. It returns a truthy value if valid.\n    // NOTE: invoke the method on the plugin instance so the `this` context\n    // is correct.\n    await cacheWillUpdatePlugin.cacheWillUpdate({\n      event,\n      request,\n      response\n    }) :\n    // Otherwise, default to considering any response status under 400 valid.\n    // This includes, by default, considering opaque responses valid.\n    response.status < 400;\n    // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status\n      });\n    }\n    // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n    if (response.redirected) {\n      response = await copyResponse(response);\n    }\n    await cacheWrapper.put({\n      event,\n      plugins,\n      response,\n      // `request` already uses `url`. We may be able to reuse it.\n      request: cacheKey === url ? request : new Request(cacheKey),\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true\n      }\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (cacheKey) {\n      const cache = await self.caches.open(this._cacheName);\n      return cache.match(cacheKey);\n    }\n    return undefined;\n  }\n  /**\n   * Returns a function that can be used within a\n   * {@link module:workbox-routing.Route} that will find a response for the\n   * incoming request against the precache.\n   *\n   * If for an unexpected reason there is a cache miss for the request,\n   * this will fall back to retrieving the `Response` via `fetch()` when\n   * `fallbackToNetwork` is `true`.\n   *\n   * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n   * response from the network if there's a precache miss.\n   * @return {module:workbox-routing~handlerCallback}\n   */\n  createHandler() {\n    let fallbackToNetwork = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return async _ref3 => {\n      let {\n        request\n      } = _ref3;\n      try {\n        const response = await this.matchPrecache(request);\n        if (response) {\n          return response;\n        }\n        // This shouldn't normally happen, but there are edge cases:\n        // https://github.com/GoogleChrome/workbox/issues/1441\n        throw new WorkboxError('missing-precache-entry', {\n          cacheName: this._cacheName,\n          url: request instanceof Request ? request.url : request\n        });\n      } catch (error) {\n        if (fallbackToNetwork) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Unable to respond with precached response. ` + `Falling back to network.`, error);\n          }\n          return fetch(request);\n        }\n        throw error;\n      }\n    };\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * If for an unexpected reason there is a cache miss when looking up `url`,\n   * this will fall back to retrieving the `Response` via `fetch()` when\n   * `fallbackToNetwork` is `true`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n   * response from the network if there's a precache miss.\n   * @return {module:workbox-routing~handlerCallback}\n   */\n  createHandlerBoundToURL(url) {\n    let fallbackToNetwork = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (!cacheKey) {\n      throw new WorkboxError('non-precached-url', {\n        url\n      });\n    }\n    const handler = this.createHandler(fallbackToNetwork);\n    const request = new Request(url);\n    return () => handler({\n      request\n    });\n  }\n}\nexport { PrecacheController };","map":{"version":3,"names":["assert","cacheNames","cacheWrapper","fetchWrapper","logger","WorkboxError","copyResponse","createCacheKey","printCleanupDetails","printInstallDetails","PrecacheController","constructor","cacheName","_cacheName","getPrecacheName","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","addToCacheList","entries","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","entry","push","revision","undefined","url","cacheKey","cacheMode","has","get","firstEntry","secondEntry","integrity","set","length","warningMessage","join","console","warn","install","event","plugins","arguments","toBePrecached","alreadyPrecached","cache","self","caches","open","alreadyCachedRequests","keys","existingCacheKeys","Set","map","request","precacheRequests","_ref","_addURLToCache","Promise","all","updatedURLs","item","notUpdatedURLs","activate","currentlyCachedRequests","expectedCacheKeys","values","deletedURLs","delete","_ref2","Request","credentials","response","fetch","cacheWillUpdatePlugin","plugin","isValidResponse","cacheWillUpdate","status","redirected","put","matchOptions","ignoreSearch","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","urlObject","URL","location","href","matchPrecache","match","createHandler","fallbackToNetwork","_ref3","error","debug","createHandlerBoundToURL","handler"],"sources":["/Users/aliciamedina/Library/Mobile Documents/com~apple~CloudDocs/Work/Proyecto Fin Grado/Electron/Ionic/Chatty-iOS/node_modules/workbox-precaching/PrecacheController.js"],"sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */\n    constructor(cacheName) {\n        this._cacheName = cacheNames.getPrecacheName(cacheName);\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = (typeof entry !== 'string' && entry.revision) ?\n                'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<module:workbox-precaching.InstallResult>}\n     */\n    async install({ event, plugins } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (plugins) {\n                assert.isArray(plugins, {\n                    moduleName: 'workbox-precaching',\n                    className: 'PrecacheController',\n                    funcName: 'install',\n                    paramName: 'plugins',\n                });\n            }\n        }\n        const toBePrecached = [];\n        const alreadyPrecached = [];\n        const cache = await self.caches.open(this._cacheName);\n        const alreadyCachedRequests = await cache.keys();\n        const existingCacheKeys = new Set(alreadyCachedRequests.map((request) => request.url));\n        for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            if (existingCacheKeys.has(cacheKey)) {\n                alreadyPrecached.push(url);\n            }\n            else {\n                toBePrecached.push({ cacheKey, url });\n            }\n        }\n        const precacheRequests = toBePrecached.map(({ cacheKey, url }) => {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            const cacheMode = this._urlsToCacheModes.get(url);\n            return this._addURLToCache({\n                cacheKey,\n                cacheMode,\n                event,\n                integrity,\n                plugins,\n                url,\n            });\n        });\n        await Promise.all(precacheRequests);\n        const updatedURLs = toBePrecached.map((item) => item.url);\n        if (process.env.NODE_ENV !== 'production') {\n            printInstallDetails(updatedURLs, alreadyPrecached);\n        }\n        return {\n            updatedURLs,\n            notUpdatedURLs: alreadyPrecached,\n        };\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<module:workbox-precaching.CleanupResult>}\n     */\n    async activate() {\n        const cache = await self.caches.open(this._cacheName);\n        const currentlyCachedRequests = await cache.keys();\n        const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n        const deletedURLs = [];\n        for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n                await cache.delete(request);\n                deletedURLs.push(request.url);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            printCleanupDetails(deletedURLs);\n        }\n        return { deletedURLs };\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.cacheKey The string to use a cache key.\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {string} [options.cacheMode] The cache mode for the network request.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     * @param {string} [options.integrity] The value to use for the `integrity`\n     * field when making the request.\n     */\n    async _addURLToCache({ cacheKey, url, cacheMode, event, plugins, integrity }) {\n        const request = new Request(url, {\n            integrity,\n            cache: cacheMode,\n            credentials: 'same-origin',\n        });\n        let response = await fetchWrapper.fetch({\n            event,\n            plugins,\n            request,\n        });\n        // Allow developers to override the default logic about what is and isn't\n        // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n        // a `CacheableResponsePlugin` instance.\n        let cacheWillUpdatePlugin;\n        for (const plugin of (plugins || [])) {\n            if ('cacheWillUpdate' in plugin) {\n                cacheWillUpdatePlugin = plugin;\n            }\n        }\n        const isValidResponse = cacheWillUpdatePlugin ?\n            // Use a callback if provided. It returns a truthy value if valid.\n            // NOTE: invoke the method on the plugin instance so the `this` context\n            // is correct.\n            await cacheWillUpdatePlugin.cacheWillUpdate({ event, request, response }) :\n            // Otherwise, default to considering any response status under 400 valid.\n            // This includes, by default, considering opaque responses valid.\n            response.status < 400;\n        // Consider this a failure, leading to the `install` handler failing, if\n        // we get back an invalid response.\n        if (!isValidResponse) {\n            throw new WorkboxError('bad-precaching-response', {\n                url,\n                status: response.status,\n            });\n        }\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        if (response.redirected) {\n            response = await copyResponse(response);\n        }\n        await cacheWrapper.put({\n            event,\n            plugins,\n            response,\n            // `request` already uses `url`. We may be able to reuse it.\n            request: cacheKey === url ? request : new Request(cacheKey),\n            cacheName: this._cacheName,\n            matchOptions: {\n                ignoreSearch: true,\n            },\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this._cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that can be used within a\n     * {@link module:workbox-routing.Route} that will find a response for the\n     * incoming request against the precache.\n     *\n     * If for an unexpected reason there is a cache miss for the request,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandler(fallbackToNetwork = true) {\n        return async ({ request }) => {\n            try {\n                const response = await this.matchPrecache(request);\n                if (response) {\n                    return response;\n                }\n                // This shouldn't normally happen, but there are edge cases:\n                // https://github.com/GoogleChrome/workbox/issues/1441\n                throw new WorkboxError('missing-precache-entry', {\n                    cacheName: this._cacheName,\n                    url: request instanceof Request ? request.url : request,\n                });\n            }\n            catch (error) {\n                if (fallbackToNetwork) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.debug(`Unable to respond with precached response. ` +\n                            `Falling back to network.`, error);\n                    }\n                    return fetch(request);\n                }\n                throw error;\n            }\n        };\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * If for an unexpected reason there is a cache miss when looking up `url`,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url, fallbackToNetwork = true) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        const handler = this.createHandler(fallbackToNetwork);\n        const request = new Request(url);\n        return () => handler({ request });\n    }\n}\nexport { PrecacheController };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
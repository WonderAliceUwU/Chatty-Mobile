{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nimport { g as getTimeGivenProgression } from './cubic-bezier.js';\nimport { a as attachComponent, d as detachComponent } from './framework-delegate.js';\nimport { s as shallowEqualStringMap } from './helpers.js';\nimport { t as transition } from './index4.js';\nconst routeOutletCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}\";\nconst RouterOutlet = /*@__PURE__*/proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionNavWillLoad = createEvent(this, \"ionNavWillLoad\", 7);\n    this.ionNavWillChange = createEvent(this, \"ionNavWillChange\", 3);\n    this.ionNavDidChange = createEvent(this, \"ionNavDidChange\", 3);\n    this.gestureOrAnimationInProgress = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = getIonMode(this);\n    /**\n     * If `true`, the router-outlet should animate the transition of components.\n     */\n    this.animated = true;\n  }\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n  async connectedCallback() {\n    const onStart = () => {\n      this.gestureOrAnimationInProgress = true;\n      if (this.swipeHandler) {\n        this.swipeHandler.onStart();\n      }\n    };\n    this.gesture = (await import('./swipe-back.js')).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), step => {\n      var _a;\n      return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step);\n    }, (shouldComplete, step, dur) => {\n      if (this.ani) {\n        this.ani.onFinish(() => {\n          this.gestureOrAnimationInProgress = false;\n          if (this.swipeHandler) {\n            this.swipeHandler.onEnd(shouldComplete);\n          }\n        }, {\n          oneTimeCallback: true\n        });\n        // Account for rounding errors in JS\n        let newStepValue = shouldComplete ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        if (!shouldComplete) {\n          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n        } else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n        }\n        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      } else {\n        this.gestureOrAnimationInProgress = false;\n      }\n    });\n    this.swipeHandlerChanged();\n  }\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n  async commit(enteringEl, leavingEl, opts) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.transition(enteringEl, leavingEl, opts);\n    } catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  /** @internal */\n  async setRouteId(id, params, direction, animation) {\n    const changed = await this.setRoot(id, params, {\n      duration: direction === 'root' ? 0 : undefined,\n      direction: direction === 'back' ? 'back' : 'forward',\n      animationBuilder: animation\n    });\n    return {\n      changed,\n      element: this.activeEl\n    };\n  }\n  /** @internal */\n  async getRouteId() {\n    const active = this.activeEl;\n    return active ? {\n      id: active.tagName,\n      element: active,\n      params: this.activeParams\n    } : undefined;\n  }\n  async setRoot(component, params, opts) {\n    if (this.activeComponent === component && shallowEqualStringMap(params, this.activeParams)) {\n      return false;\n    }\n    // attach entering view to DOM\n    const leavingEl = this.activeEl;\n    const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);\n    this.activeComponent = component;\n    this.activeEl = enteringEl;\n    this.activeParams = params;\n    // commit animation\n    await this.commit(enteringEl, leavingEl, opts);\n    await detachComponent(this.delegate, leavingEl);\n    return true;\n  }\n  async transition(enteringEl, leavingEl) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (leavingEl === enteringEl) {\n      return false;\n    }\n    // emit nav will change event\n    this.ionNavWillChange.emit();\n    const {\n      el,\n      mode\n    } = this;\n    const animated = this.animated && config.getBoolean('animated', true);\n    const animationBuilder = opts.animationBuilder || this.animation || config.get('navAnimation');\n    await transition(Object.assign(Object.assign({\n      mode,\n      animated,\n      enteringEl,\n      leavingEl,\n      baseEl: el,\n      progressCallback: opts.progressAnimation ? ani => {\n        /**\n         * Because this progress callback is called asynchronously\n         * it is possible for the gesture to start and end before\n         * the animation is ever set. In that scenario, we should\n         * immediately call progressEnd so that the transition promise\n         * resolves and the gesture does not get locked up.\n         */\n        if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n          this.gestureOrAnimationInProgress = true;\n          ani.onFinish(() => {\n            this.gestureOrAnimationInProgress = false;\n            if (this.swipeHandler) {\n              this.swipeHandler.onEnd(false);\n            }\n          }, {\n            oneTimeCallback: true\n          });\n          /**\n           * Playing animation to beginning\n           * with a duration of 0 prevents\n           * any flickering when the animation\n           * is later cleaned up.\n           */\n          ani.progressEnd(0, 0, 0);\n        } else {\n          this.ani = ani;\n        }\n      } : undefined\n    }, opts), {\n      animationBuilder\n    }));\n    // emit nav changed event\n    this.ionNavDidChange.emit();\n    return true;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise(r => resolve = r);\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  render() {\n    return h(\"slot\", null);\n  }\n  get el() {\n    return this;\n  }\n  static get watchers() {\n    return {\n      \"swipeHandler\": [\"swipeHandlerChanged\"]\n    };\n  }\n  static get style() {\n    return routeOutletCss;\n  }\n}, [1, \"ion-router-outlet\", {\n  \"mode\": [1025],\n  \"delegate\": [16],\n  \"animated\": [4],\n  \"animation\": [16],\n  \"swipeHandler\": [16],\n  \"commit\": [64],\n  \"setRouteId\": [64],\n  \"getRouteId\": [64]\n}]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-router-outlet\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-router-outlet\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, RouterOutlet);\n        }\n        break;\n    }\n  });\n}\nconst IonRouterOutlet = RouterOutlet;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonRouterOutlet, defineCustomElement };","map":{"version":3,"names":["proxyCustomElement","HTMLElement","createEvent","h","b","getIonMode","c","config","g","getTimeGivenProgression","a","attachComponent","d","detachComponent","s","shallowEqualStringMap","t","transition","routeOutletCss","RouterOutlet","constructor","__registerHost","__attachShadow","ionNavWillLoad","ionNavWillChange","ionNavDidChange","gestureOrAnimationInProgress","mode","animated","swipeHandlerChanged","gesture","enable","swipeHandler","undefined","connectedCallback","onStart","createSwipeBackGesture","el","canStart","step","_a","ani","progressStep","shouldComplete","dur","onFinish","onEnd","oneTimeCallback","newStepValue","easing","progressEnd","componentWillLoad","emit","disconnectedCallback","destroy","commit","enteringEl","leavingEl","opts","unlock","lock","changed","e","console","error","setRouteId","id","params","direction","animation","setRoot","duration","animationBuilder","element","activeEl","getRouteId","active","tagName","activeParams","component","activeComponent","delegate","arguments","length","getBoolean","get","Object","assign","baseEl","progressCallback","progressAnimation","p","waitPromise","resolve","Promise","r","render","watchers","style","defineCustomElement$1","customElements","components","forEach","define","IonRouterOutlet","defineCustomElement"],"sources":["/Users/aliciamedina/Library/Mobile Documents/com~apple~CloudDocs/Work/Proyecto Fin Grado/Electron/Ionic/Chatty-iOS/node_modules/@ionic/core/components/ion-router-outlet.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nimport { g as getTimeGivenProgression } from './cubic-bezier.js';\nimport { a as attachComponent, d as detachComponent } from './framework-delegate.js';\nimport { s as shallowEqualStringMap } from './helpers.js';\nimport { t as transition } from './index4.js';\n\nconst routeOutletCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}\";\n\nconst RouterOutlet = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionNavWillLoad = createEvent(this, \"ionNavWillLoad\", 7);\n    this.ionNavWillChange = createEvent(this, \"ionNavWillChange\", 3);\n    this.ionNavDidChange = createEvent(this, \"ionNavDidChange\", 3);\n    this.gestureOrAnimationInProgress = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = getIonMode(this);\n    /**\n     * If `true`, the router-outlet should animate the transition of components.\n     */\n    this.animated = true;\n  }\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n  async connectedCallback() {\n    const onStart = () => {\n      this.gestureOrAnimationInProgress = true;\n      if (this.swipeHandler) {\n        this.swipeHandler.onStart();\n      }\n    };\n    this.gesture = (await import('./swipe-back.js')).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), (step) => { var _a; return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step); }, (shouldComplete, step, dur) => {\n      if (this.ani) {\n        this.ani.onFinish(() => {\n          this.gestureOrAnimationInProgress = false;\n          if (this.swipeHandler) {\n            this.swipeHandler.onEnd(shouldComplete);\n          }\n        }, { oneTimeCallback: true });\n        // Account for rounding errors in JS\n        let newStepValue = shouldComplete ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        if (!shouldComplete) {\n          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n        }\n        else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n        }\n        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      }\n      else {\n        this.gestureOrAnimationInProgress = false;\n      }\n    });\n    this.swipeHandlerChanged();\n  }\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n  async commit(enteringEl, leavingEl, opts) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.transition(enteringEl, leavingEl, opts);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  /** @internal */\n  async setRouteId(id, params, direction, animation) {\n    const changed = await this.setRoot(id, params, {\n      duration: direction === 'root' ? 0 : undefined,\n      direction: direction === 'back' ? 'back' : 'forward',\n      animationBuilder: animation,\n    });\n    return {\n      changed,\n      element: this.activeEl,\n    };\n  }\n  /** @internal */\n  async getRouteId() {\n    const active = this.activeEl;\n    return active\n      ? {\n        id: active.tagName,\n        element: active,\n        params: this.activeParams,\n      }\n      : undefined;\n  }\n  async setRoot(component, params, opts) {\n    if (this.activeComponent === component && shallowEqualStringMap(params, this.activeParams)) {\n      return false;\n    }\n    // attach entering view to DOM\n    const leavingEl = this.activeEl;\n    const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);\n    this.activeComponent = component;\n    this.activeEl = enteringEl;\n    this.activeParams = params;\n    // commit animation\n    await this.commit(enteringEl, leavingEl, opts);\n    await detachComponent(this.delegate, leavingEl);\n    return true;\n  }\n  async transition(enteringEl, leavingEl, opts = {}) {\n    if (leavingEl === enteringEl) {\n      return false;\n    }\n    // emit nav will change event\n    this.ionNavWillChange.emit();\n    const { el, mode } = this;\n    const animated = this.animated && config.getBoolean('animated', true);\n    const animationBuilder = opts.animationBuilder || this.animation || config.get('navAnimation');\n    await transition(Object.assign(Object.assign({ mode,\n      animated,\n      enteringEl,\n      leavingEl, baseEl: el, progressCallback: opts.progressAnimation\n        ? (ani) => {\n          /**\n           * Because this progress callback is called asynchronously\n           * it is possible for the gesture to start and end before\n           * the animation is ever set. In that scenario, we should\n           * immediately call progressEnd so that the transition promise\n           * resolves and the gesture does not get locked up.\n           */\n          if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n            this.gestureOrAnimationInProgress = true;\n            ani.onFinish(() => {\n              this.gestureOrAnimationInProgress = false;\n              if (this.swipeHandler) {\n                this.swipeHandler.onEnd(false);\n              }\n            }, { oneTimeCallback: true });\n            /**\n             * Playing animation to beginning\n             * with a duration of 0 prevents\n             * any flickering when the animation\n             * is later cleaned up.\n             */\n            ani.progressEnd(0, 0, 0);\n          }\n          else {\n            this.ani = ani;\n          }\n        }\n        : undefined }, opts), { animationBuilder }));\n    // emit nav changed event\n    this.ionNavDidChange.emit();\n    return true;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise((r) => (resolve = r));\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  render() {\n    return h(\"slot\", null);\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"swipeHandler\": [\"swipeHandlerChanged\"]\n  }; }\n  static get style() { return routeOutletCss; }\n}, [1, \"ion-router-outlet\", {\n    \"mode\": [1025],\n    \"delegate\": [16],\n    \"animated\": [4],\n    \"animation\": [16],\n    \"swipeHandler\": [16],\n    \"commit\": [64],\n    \"setRouteId\": [64],\n    \"getRouteId\": [64]\n  }]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-router-outlet\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-router-outlet\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, RouterOutlet);\n      }\n      break;\n  } });\n}\n\nconst IonRouterOutlet = RouterOutlet;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonRouterOutlet, defineCustomElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}